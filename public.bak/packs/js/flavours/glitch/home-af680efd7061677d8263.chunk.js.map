{"version":3,"sources":["webpack:///app/javascript/home/mastodon/live/app/javascript/flavours/glitch/packs/home.js","webpack:///app/javascript/home/mastodon/live/app/javascript/flavours/glitch/load_polyfills.js","webpack:///app/javascript/home/mastodon/live/app/javascript/packs/public-path.js"],"names":["loadPolyfills","then","async","default","main","catch","e","console","error","needsBasePolyfills","Array","prototype","includes","HTMLCanvasElement","toBlob","window","Intl","Number","isNaN","Object","assign","values","Symbol","Promise","finally","needsExtraPolyfills","AbortController","IntersectionObserver","IntersectionObserverEntry","requestIdleCallback","all","removeOuterSlashes","string","replace","cdnHost","document","querySelector","__webpack_public_path__","host","path","formattedHost","test","formatPublicPath","content","process"],"mappings":"qIAAA,0BAGAA,cAAgBC,MAAKC,UACnB,MAAQC,QAASC,SAAe,uDAEhC,OAAOA,OACNC,OAAMC,IACPC,QAAQC,MAAMF,O,iCCiCDN,IA7Bf,WACE,MAAMS,IACJC,MAAMC,UAAUC,UAChBC,kBAAkBF,UAAUG,QAC5BC,OAAOC,MACPC,OAAOC,OACPC,OAAOC,QACPD,OAAOE,QACPN,OAAOO,QACPC,QAAQZ,UAAUa,SAMdC,IACJV,OAAOW,iBACPX,OAAOY,sBACPZ,OAAOa,2BACP,mBAAoBA,0BAA0BjB,WAC9CI,OAAOc,qBAGT,OAAON,QAAQO,IAAI,CACjBrB,GA/BK,qDAgCLgB,GA5BK,yD,mBCLT,SAASM,EAAmBC,GAC1B,OAAOA,EAAOC,QAAQ,OAAQ,IAAIA,QAAQ,OAAQ,IAYpD,MAAMC,EAAUC,SAASC,cAAc,uBAGvCC,IAZA,SAA0BC,EAAWC,QAAP,IAAJD,MAAO,SAAQ,IAAJC,MAAO,IAC1C,IAAIC,EAAgBT,EAAmBO,GAKvC,OAJIE,IAAkB,SAASC,KAAKD,KAClCA,EAAiB,KAAIA,KAGf,GAAEA,KADYT,EAAmBQ,MAOjBG,CAAiBR,EAAUA,EAAQS,QAAU,GAAIC,W","file":"js/flavours/glitch/home-af680efd7061677d8263.chunk.js","sourcesContent":["import 'packs/public-path';\nimport loadPolyfills from 'flavours/glitch/load_polyfills';\n\nloadPolyfills().then(async () => {\n  const { default: main } = await import('flavours/glitch/main');\n\n  return main();\n}).catch(e => {\n  console.error(e);\n});\n","// Convenience function to load polyfills and return a promise when it's done.\n// If there are no polyfills, then this is just Promise.resolve() which means\n// it will execute in the same tick of the event loop (i.e. near-instant).\n\nfunction importBasePolyfills() {\n  return import(/* webpackChunkName: \"base_polyfills\" */ './base_polyfills');\n}\n\nfunction importExtraPolyfills() {\n  return import(/* webpackChunkName: \"extra_polyfills\" */ './extra_polyfills');\n}\n\nfunction loadPolyfills() {\n  const needsBasePolyfills = !(\n    Array.prototype.includes &&\n    HTMLCanvasElement.prototype.toBlob &&\n    window.Intl &&\n    Number.isNaN &&\n    Object.assign &&\n    Object.values &&\n    window.Symbol &&\n    Promise.prototype.finally\n  );\n\n  // Latest version of Firefox and Safari do not have IntersectionObserver.\n  // Edge does not have requestIdleCallback.\n  // This avoids shipping them all the polyfills.\n  const needsExtraPolyfills = !(\n    window.AbortController &&\n    window.IntersectionObserver &&\n    window.IntersectionObserverEntry &&\n    'isIntersecting' in IntersectionObserverEntry.prototype &&\n    window.requestIdleCallback\n  );\n\n  return Promise.all([\n    needsBasePolyfills && importBasePolyfills(),\n    needsExtraPolyfills && importExtraPolyfills(),\n  ]);\n}\n\nexport default loadPolyfills;\n","// Dynamically set webpack's loading path depending on a meta header, in order\n// to share the same assets regardless of instance configuration.\n// See https://webpack.js.org/guides/public-path/#on-the-fly\n\nfunction removeOuterSlashes(string) {\n  return string.replace(/^\\/*/, '').replace(/\\/*$/, '');\n}\n\nfunction formatPublicPath(host = '', path = '') {\n  let formattedHost = removeOuterSlashes(host);\n  if (formattedHost && !/^http/i.test(formattedHost)) {\n    formattedHost = `//${formattedHost}`;\n  }\n  const formattedPath = removeOuterSlashes(path);\n  return `${formattedHost}/${formattedPath}/`;\n}\n\nconst cdnHost = document.querySelector('meta[name=cdn-host]');\n\n// eslint-disable-next-line no-undef\n__webpack_public_path__ = formatPublicPath(cdnHost ? cdnHost.content : '', process.env.PUBLIC_OUTPUT_PATH);\n"],"sourceRoot":""}